<?php

declare(strict_types=1);

namespace CineHubX\PhpBot;

use PDO;
use PDOException;

final class Database
{
    private const SCHEMA = <<<'SQL'
CREATE TABLE IF NOT EXISTS content (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type TEXT NOT NULL,
    title TEXT NOT NULL,
    keywords TEXT,
    description TEXT,
    year INTEGER,
    country TEXT,
    language TEXT,
    genres TEXT,
    poster_file_id TEXT,
    parts_total INTEGER,
    parts_count INTEGER DEFAULT 0,
    views INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS parts (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content_id INTEGER NOT NULL,
    season INTEGER DEFAULT 1,
    part_number INTEGER NOT NULL,
    channel_message_id BIGINT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(content_id, season, part_number)
);

CREATE TABLE IF NOT EXISTS users (
    user_id BIGINT PRIMARY KEY,
    username TEXT,
    joined_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    is_vip BOOLEAN DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS favorites (
    user_id BIGINT NOT NULL,
    content_id INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, content_id)
);

CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT
);

CREATE TABLE IF NOT EXISTS bot_state (
    user_id BIGINT PRIMARY KEY,
    state TEXT NOT NULL,
    data JSONB,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
SQL;

    private ?PDO $pdo = null;
    private string $activeUrl;
    private readonly float $settingsCacheTtl;

    /** @var array<string, array{expires_at: float, value: ?string}> */
    private array $settingsCache = [];

    public function __construct(
        private readonly string $primaryUrl,
        private readonly ?string $fallbackUrl = null,
        float $settingsCacheTtl = 15.0,
    ) {
        $this->activeUrl = $this->primaryUrl;
        $this->settingsCacheTtl = $settingsCacheTtl;
    }

    public function init(): void
    {
        if ($this->pdo !== null) {
            return;
        }

        $this->assertPostgresDriverAvailable();

        try {
            $this->connectWithRetries($this->primaryUrl);
            $this->activeUrl = $this->primaryUrl;
        } catch (PDOException $e) {
            if ($this->fallbackUrl === null || $this->fallbackUrl === $this->primaryUrl) {
                throw $e;
            }
            error_log('Primary DB connection failed, trying fallback DATABASE_PUBLIC_URL');
            $this->connectWithRetries($this->fallbackUrl);
            $this->activeUrl = $this->fallbackUrl;
        }

        $this->initializeSchema();
    }

    private function assertPostgresDriverAvailable(): void
    {
        if (!extension_loaded('pdo')) {
            throw new \RuntimeException(
                'PDO extension is not loaded. Ensure your runtime has ext-pdo enabled.',
            );
        }

        if (!in_array('pgsql', PDO::getAvailableDrivers(), true)) {
            throw new \RuntimeException(
                'PostgreSQL PDO driver is missing (pdo_pgsql). Railway/Railpack: set RAILPACK_PHP_EXTENSIONS=pdo_pgsql,pgsql and redeploy.',
            );
        }
    }

    public function close(): void
    {
        $this->pdo = null;
        $this->settingsCache = [];
    }

    private function reconnect(): void
    {
        $candidates = [$this->activeUrl];
        if ($this->primaryUrl !== $this->activeUrl) {
            $candidates[] = $this->primaryUrl;
        }
        if ($this->fallbackUrl !== null && !in_array($this->fallbackUrl, $candidates, true)) {
            $candidates[] = $this->fallbackUrl;
        }

        $last = null;
        foreach ($candidates as $candidate) {
            try {
                $this->connectWithRetries($candidate);
                $this->activeUrl = $candidate;
                $this->initializeSchema();
                return;
            } catch (PDOException $e) {
                $last = $e;
            }
        }

        if ($last !== null) {
            throw $last;
        }
    }

    private function connectWithRetries(string $url): void
    {
        $retries = 5;
        $backoff = 0.5;
        $maxBackoff = 5.0;

        for ($attempt = 1; $attempt <= $retries; $attempt++) {
            try {
                $this->pdo = $this->createPdo($url);
                return;
            } catch (PDOException $e) {
                if ($attempt >= $retries) {
                    throw $e;
                }
                $safeUrl = $this->sanitizeDatabaseUrlForLog($url);
                error_log(sprintf('Database connection failed (%s). Retrying in %.1fs (%d/%d)', $safeUrl, $backoff, $attempt, $retries));
                usleep((int) ($backoff * 1_000_000));
                $backoff = min($backoff * 2, $maxBackoff);
            }
        }
    }

    private function sanitizeDatabaseUrlForLog(string $url): string
    {
        if (str_starts_with($url, 'pgsql:')) {
            return 'pgsql:(redacted)';
        }

        $parts = parse_url($url);
        if ($parts === false) {
            return '(invalid database url)';
        }

        $scheme = isset($parts['scheme']) ? (string) $parts['scheme'] : 'postgresql';
        $host = isset($parts['host']) ? (string) $parts['host'] : 'unknown-host';
        $port = isset($parts['port']) ? ':' . (int) $parts['port'] : '';
        $dbName = isset($parts['path']) ? ltrim((string) $parts['path'], '/') : '';

        if ($dbName === '') {
            return sprintf('%s://%s%s', $scheme, $host, $port);
        }

        return sprintf('%s://%s%s/%s', $scheme, $host, $port, $dbName);
    }

    private function createPdo(string $url): PDO
    {
        [$dsn, $user, $pass] = $this->toPdoParams($url);

        return new PDO($dsn, $user, $pass, [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_EMULATE_PREPARES => false,
        ]);
    }

    /**
     * @return array{0: string, 1: ?string, 2: ?string}
     */
    private function toPdoParams(string $url): array
    {
        if (str_starts_with($url, 'pgsql:')) {
            return [$url, null, null];
        }

        if (!str_starts_with($url, 'postgres://') && !str_starts_with($url, 'postgresql://')) {
            throw new \RuntimeException('Unsupported database URL. Use postgres:// or pgsql:');
        }

        $parts = parse_url($url);
        if ($parts === false) {
            throw new \RuntimeException('Invalid database URL');
        }

        $host = $parts['host'] ?? 'localhost';
        $port = (int) ($parts['port'] ?? 5432);
        $user = isset($parts['user']) ? rawurldecode((string) $parts['user']) : null;
        $pass = isset($parts['pass']) ? rawurldecode((string) $parts['pass']) : null;
        $path = (string) ($parts['path'] ?? '');
        $dbName = ltrim($path, '/');
        if ($dbName === '') {
            throw new \RuntimeException('Database name missing in URL');
        }

        parse_str((string) ($parts['query'] ?? ''), $query);
        $sslMode = isset($query['sslmode']) ? (string) $query['sslmode'] : null;

        $dsn = sprintf('pgsql:host=%s;port=%d;dbname=%s', $host, $port, $dbName);
        if ($sslMode !== null && $sslMode !== '') {
            $dsn .= ';sslmode=' . $sslMode;
        }

        return [$dsn, $user, $pass];
    }

    private function initializeSchema(): void
    {
        $pdo = $this->pdo();
        $pdo->exec(self::SCHEMA);

        $this->execute('ALTER TABLE content ADD COLUMN IF NOT EXISTS parts_total INTEGER');
        $this->execute('ALTER TABLE users ADD COLUMN IF NOT EXISTS is_vip BOOLEAN DEFAULT FALSE');
        $this->execute('ALTER TABLE parts ADD COLUMN IF NOT EXISTS season INTEGER DEFAULT 1');
        $this->execute('UPDATE parts SET season = 1 WHERE season IS NULL');
        $this->execute('ALTER TABLE parts DROP CONSTRAINT IF EXISTS parts_content_id_part_number_key');
        $this->execute(
            <<<'SQL'
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint
        WHERE conname = 'parts_content_id_season_part_number_key'
    ) THEN
        ALTER TABLE parts
        ADD CONSTRAINT parts_content_id_season_part_number_key
        UNIQUE(content_id, season, part_number);
    END IF;
END $$;
SQL
        );

        $this->execute('CREATE INDEX IF NOT EXISTS idx_content_created_at_desc ON content (created_at DESC)');
        $this->execute('CREATE INDEX IF NOT EXISTS idx_content_views_desc ON content (views DESC)');
        $this->execute('CREATE INDEX IF NOT EXISTS idx_favorites_user_created_at_desc ON favorites (user_id, created_at DESC)');

        try {
            $this->execute('CREATE EXTENSION IF NOT EXISTS pg_trgm');
            $this->execute('CREATE INDEX IF NOT EXISTS idx_content_title_trgm ON content USING GIN (title gin_trgm_ops)');
            $this->execute('CREATE INDEX IF NOT EXISTS idx_content_keywords_trgm ON content USING GIN (keywords gin_trgm_ops)');
        } catch (\Throwable $e) {
            error_log('Skipping trigram indexes: ' . $e->getMessage());
        }
    }

    /** @return array<string, mixed>|null */
    private function fetchOne(string $query, array $params = []): ?array
    {
        $stmt = $this->query($query, $params);
        $row = $stmt->fetch();

        return $row === false ? null : $row;
    }

    /**
     * @return list<array<string, mixed>>
     */
    private function fetchAll(string $query, array $params = []): array
    {
        $stmt = $this->query($query, $params);
        $rows = $stmt->fetchAll();

        return is_array($rows) ? $rows : [];
    }

    private function fetchVal(string $query, array $params = []): mixed
    {
        $stmt = $this->query($query, $params);
        return $stmt->fetchColumn();
    }

    private function execute(string $query, array $params = []): void
    {
        $this->query($query, $params);
    }

    private function query(string $query, array $params = []): \PDOStatement
    {
        $pdo = $this->pdo();
        try {
            $stmt = $pdo->prepare($query);
            $stmt->execute(array_values($params));
            return $stmt;
        } catch (PDOException $e) {
            $this->reconnect();
            $pdo = $this->pdo();
            $stmt = $pdo->prepare($query);
            $stmt->execute(array_values($params));
            return $stmt;
        }
    }

    private function pdo(): PDO
    {
        if ($this->pdo === null) {
            throw new \RuntimeException('Database not initialized');
        }

        return $this->pdo;
    }

    public function upsertUser(int $userId, ?string $username): void
    {
        $this->execute(
            'INSERT INTO users(user_id, username) VALUES(?, ?) ON CONFLICT (user_id) DO NOTHING',
            [$userId, $username],
        );
    }

    public function addContent(
        string $contentType,
        string $title,
        ?string $keywords,
        ?string $description,
        ?int $year,
        ?string $country,
        ?string $language,
        ?string $genres,
        ?string $posterFileId,
        ?int $partsTotal,
    ): int {
        $rowId = $this->fetchVal(
            <<<'SQL'
INSERT INTO content(
    type, title, keywords, description, year, country, language, genres, poster_file_id, parts_total
) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
SQL,
            [
                $contentType,
                $title,
                $keywords,
                $description,
                $year,
                $country,
                $language,
                $genres,
                $posterFileId,
                $partsTotal,
            ],
        );

        return $rowId === false ? 0 : (int) $rowId;
    }

    public function addPart(int $contentId, int $partNumber, int $channelMessageId, int $season = 1): int
    {
        $partId = $this->fetchVal(
            <<<'SQL'
INSERT INTO parts(content_id, season, part_number, channel_message_id)
VALUES(?, ?, ?, ?)
ON CONFLICT (content_id, season, part_number) DO NOTHING
RETURNING id
SQL,
            [$contentId, $season, $partNumber, $channelMessageId],
        );

        $this->execute(
            'UPDATE content SET parts_count = (SELECT COUNT(1) FROM parts WHERE content_id = ?) WHERE id = ?',
            [$contentId, $contentId],
        );

        return $partId === false ? 0 : (int) $partId;
    }

    /** @return array<string, mixed>|null */
    public function getContent(int $contentId): ?array
    {
        return $this->fetchOne('SELECT * FROM content WHERE id = ?', [$contentId]);
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function searchContent(string $query, int $limit, int $offset): array
    {
        $like = '%' . $query . '%';

        if (ctype_digit(trim($query))) {
            $contentId = (int) trim($query);
            return $this->fetchAll(
                <<<'SQL'
SELECT * FROM content
WHERE id = ? OR title ILIKE ? OR keywords ILIKE ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
SQL,
                [$contentId, $like, $like, $limit, $offset],
            );
        }

        return $this->fetchAll(
            <<<'SQL'
SELECT * FROM content
WHERE title ILIKE ? OR keywords ILIKE ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
SQL,
            [$like, $like, $limit, $offset],
        );
    }

    public function countSearch(string $query): int
    {
        $like = '%' . $query . '%';

        if (ctype_digit(trim($query))) {
            $contentId = (int) trim($query);
            $row = $this->fetchOne(
                'SELECT COUNT(1) AS cnt FROM content WHERE id = ? OR title ILIKE ? OR keywords ILIKE ?',
                [$contentId, $like, $like],
            );
        } else {
            $row = $this->fetchOne(
                'SELECT COUNT(1) AS cnt FROM content WHERE title ILIKE ? OR keywords ILIKE ?',
                [$like, $like],
            );
        }

        return $row === null ? 0 : (int) $row['cnt'];
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function listLatest(int $limit, int $offset): array
    {
        return $this->fetchAll('SELECT * FROM content ORDER BY created_at DESC LIMIT ? OFFSET ?', [$limit, $offset]);
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function listTop(int $limit, int $offset): array
    {
        return $this->fetchAll('SELECT * FROM content ORDER BY views DESC LIMIT ? OFFSET ?', [$limit, $offset]);
    }

    public function countContent(): int
    {
        $row = $this->fetchOne('SELECT COUNT(1) AS cnt FROM content');
        return $row === null ? 0 : (int) $row['cnt'];
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function listByType(string $contentType): array
    {
        return $this->fetchAll('SELECT * FROM content WHERE type = ? ORDER BY created_at DESC', [$contentType]);
    }

    public function countByType(string $contentType): int
    {
        $row = $this->fetchOne('SELECT COUNT(1) AS cnt FROM content WHERE type = ?', [$contentType]);
        return $row === null ? 0 : (int) $row['cnt'];
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function getParts(int $contentId, ?int $season = null): array
    {
        if ($season === null) {
            return $this->fetchAll(
                'SELECT * FROM parts WHERE content_id = ? ORDER BY season ASC, part_number ASC',
                [$contentId],
            );
        }

        return $this->fetchAll(
            'SELECT * FROM parts WHERE content_id = ? AND season = ? ORDER BY part_number ASC',
            [$contentId, $season],
        );
    }

    /**
     * @return list<int>
     */
    public function listSeasons(int $contentId): array
    {
        $rows = $this->fetchAll(
            'SELECT DISTINCT season FROM parts WHERE content_id = ? ORDER BY season ASC',
            [$contentId],
        );

        return array_values(array_map(static fn (array $row): int => (int) $row['season'], $rows));
    }

    /** @return array<string, mixed>|null */
    public function getPartByNumber(int $contentId, int $partNumber, int $season = 1): ?array
    {
        return $this->fetchOne(
            'SELECT * FROM parts WHERE content_id = ? AND season = ? AND part_number = ?',
            [$contentId, $season, $partNumber],
        );
    }

    /** @return array<string, mixed>|null */
    public function getPart(int $partId): ?array
    {
        return $this->fetchOne('SELECT * FROM parts WHERE id = ?', [$partId]);
    }

    public function incrementViews(int $contentId): void
    {
        $this->execute('UPDATE content SET views = views + 1 WHERE id = ?', [$contentId]);
    }

    public function updateContentField(int $contentId, string $field, mixed $value): void
    {
        $allowed = [
            'title',
            'keywords',
            'description',
            'year',
            'country',
            'language',
            'genres',
            'parts_total',
        ];

        if (!in_array($field, $allowed, true)) {
            throw new \InvalidArgumentException('Invalid field');
        }

        $this->execute(sprintf('UPDATE content SET %s = ? WHERE id = ?', $field), [$value, $contentId]);
    }

    public function deleteContent(int $contentId): void
    {
        $this->execute('DELETE FROM parts WHERE content_id = ?', [$contentId]);
        $this->execute('DELETE FROM favorites WHERE content_id = ?', [$contentId]);
        $this->execute('DELETE FROM content WHERE id = ?', [$contentId]);
    }

    public function toggleFavorite(int $userId, int $contentId): bool
    {
        $existing = $this->fetchOne('SELECT 1 FROM favorites WHERE user_id = ? AND content_id = ?', [$userId, $contentId]);
        if ($existing !== null) {
            $this->execute('DELETE FROM favorites WHERE user_id = ? AND content_id = ?', [$userId, $contentId]);
            return false;
        }

        $this->execute(
            'INSERT INTO favorites(user_id, content_id) VALUES(?, ?) ON CONFLICT DO NOTHING',
            [$userId, $contentId],
        );

        return true;
    }

    public function isFavorite(int $userId, int $contentId): bool
    {
        $existing = $this->fetchOne('SELECT 1 FROM favorites WHERE user_id = ? AND content_id = ?', [$userId, $contentId]);
        return $existing !== null;
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function listFavorites(int $userId, int $limit, int $offset): array
    {
        return $this->fetchAll(
            <<<'SQL'
SELECT c.* FROM content c
JOIN favorites f ON f.content_id = c.id
WHERE f.user_id = ?
ORDER BY f.created_at DESC
LIMIT ? OFFSET ?
SQL,
            [$userId, $limit, $offset],
        );
    }

    public function countFavorites(int $userId): int
    {
        $row = $this->fetchOne('SELECT COUNT(1) AS cnt FROM favorites WHERE user_id = ?', [$userId]);
        return $row === null ? 0 : (int) $row['cnt'];
    }

    /** @return array{content:int,parts:int,users:int,views:int} */
    public function stats(): array
    {
        $content = $this->fetchOne('SELECT COUNT(1) AS cnt FROM content');
        $parts = $this->fetchOne('SELECT COUNT(1) AS cnt FROM parts');
        $users = $this->fetchOne('SELECT COUNT(1) AS cnt FROM users');
        $views = $this->fetchOne('SELECT SUM(views) AS cnt FROM content');

        return [
            'content' => $content === null ? 0 : (int) $content['cnt'],
            'parts' => $parts === null ? 0 : (int) $parts['cnt'],
            'users' => $users === null ? 0 : (int) $users['cnt'],
            'views' => ($views === null || $views['cnt'] === null) ? 0 : (int) $views['cnt'],
        ];
    }

    /** @return list<int> */
    public function listUserIds(): array
    {
        $rows = $this->fetchAll('SELECT user_id FROM users');
        return array_values(array_map(static fn (array $row): int => (int) $row['user_id'], $rows));
    }

    public function getSetting(string $key): ?string
    {
        $now = microtime(true);
        if (isset($this->settingsCache[$key])) {
            $cached = $this->settingsCache[$key];
            if ($cached['expires_at'] > $now) {
                return $cached['value'];
            }
            unset($this->settingsCache[$key]);
        }

        $row = $this->fetchOne('SELECT value FROM settings WHERE key = ?', [$key]);
        $value = $row['value'] ?? null;
        $this->settingsCache[$key] = [
            'expires_at' => $now + $this->settingsCacheTtl,
            'value' => $value !== null ? (string) $value : null,
        ];

        return $value !== null ? (string) $value : null;
    }

    public function setSetting(string $key, ?string $value): void
    {
        if ($value === null) {
            $this->execute('DELETE FROM settings WHERE key = ?', [$key]);
            $this->settingsCache[$key] = [
                'expires_at' => microtime(true) + $this->settingsCacheTtl,
                'value' => null,
            ];
            return;
        }

        $this->execute(
            'INSERT INTO settings(key, value) VALUES(?, ?) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value',
            [$key, $value],
        );

        $this->settingsCache[$key] = [
            'expires_at' => microtime(true) + $this->settingsCacheTtl,
            'value' => $value,
        ];
    }

    /**
     * @param list<int> $default
     * @return list<int>
     */
    public function getForcedChannels(array $default): array
    {
        $raw = $this->getSetting('forced_channels');
        if ($raw === null || trim($raw) === '') {
            return $default;
        }

        $result = [];
        foreach (explode(',', $raw) as $item) {
            $item = trim($item);
            if ($item === '' || !is_numeric($item)) {
                continue;
            }
            $result[] = (int) $item;
        }

        return $result;
    }

    /** @param list<int> $channels */
    public function setForcedChannels(array $channels): void
    {
        $value = implode(',', array_map(static fn (int $id): string => (string) $id, $channels));
        $this->setSetting('forced_channels', $value !== '' ? $value : null);
    }

    /**
     * @param array<int, string> $default
     * @return array<int, string>
     */
    public function getForcedLinks(array $default): array
    {
        $raw = $this->getSetting('forced_links');
        if ($raw === null || trim($raw) === '') {
            return $default;
        }

        return Utils::parseForceLinks($raw);
    }

    /** @param array<int, string> $links */
    public function setForcedLinks(array $links): void
    {
        $chunks = [];
        foreach ($links as $key => $url) {
            $chunks[] = $key . '|' . $url;
        }
        $value = implode(',', $chunks);
        $this->setSetting('forced_links', $value !== '' ? $value : null);
    }

    /**
     * @param list<int> $default
     * @return list<int>
     */
    public function getAdminIds(array $default): array
    {
        $raw = $this->getSetting('admin_ids');
        if ($raw === null || trim($raw) === '') {
            return $default;
        }

        $result = [];
        foreach (explode(',', $raw) as $item) {
            $item = trim($item);
            if ($item === '' || !is_numeric($item)) {
                continue;
            }
            $result[] = (int) $item;
        }

        return $result;
    }

    /** @param list<int> $admins */
    public function setAdminIds(array $admins): void
    {
        $value = implode(',', array_map(static fn (int $id): string => (string) $id, $admins));
        $this->setSetting('admin_ids', $value !== '' ? $value : null);
    }

    /** @return array{state:string,data:array<string,mixed>}|null */
    public function getState(int $userId): ?array
    {
        $row = $this->fetchOne('SELECT state, data FROM bot_state WHERE user_id = ?', [$userId]);
        if ($row === null) {
            return null;
        }

        $data = [];
        if (isset($row['data']) && $row['data'] !== null && $row['data'] !== '') {
            $decoded = json_decode((string) $row['data'], true);
            if (is_array($decoded)) {
                $data = $decoded;
            }
        }

        return [
            'state' => (string) $row['state'],
            'data' => $data,
        ];
    }

    /** @param array<string, mixed> $data */
    public function setState(int $userId, string $state, array $data = []): void
    {
        $this->execute(
            <<<'SQL'
INSERT INTO bot_state(user_id, state, data, updated_at)
VALUES(?, ?, ?::jsonb, CURRENT_TIMESTAMP)
ON CONFLICT (user_id) DO UPDATE
SET state = EXCLUDED.state,
    data = EXCLUDED.data,
    updated_at = CURRENT_TIMESTAMP
SQL,
            [$userId, $state, json_encode($data, JSON_UNESCAPED_UNICODE)],
        );
    }

    public function clearState(int $userId): void
    {
        $this->execute('DELETE FROM bot_state WHERE user_id = ?', [$userId]);
    }
}
